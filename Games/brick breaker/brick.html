<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Brick Breaker</title>
<style>
  *{box-sizing:border-box}
  body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0f1724,#042031);font-family:Inter,system-ui,Arial;color:#fff}
  .wrap{width:94vw;max-width:900px;padding:12px;text-align:center}
  h1{margin:0 0 8px}
  #stage{background:#07172a;border-radius:10px;margin:0 auto;display:block;touch-action:none}
  .controls{display:flex;justify-content:space-between;margin-top:10px}
  button{background:#ffd54f;border:none;padding:8px 12px;border-radius:8px;color:#222;font-weight:700;cursor:pointer}
  .info{display:flex;gap:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>ðŸ§± Brick Breaker</h1>
  <canvas id="stage" width="900" height="520"></canvas>
  <div class="controls">
    <div class="info">Score: <span id="score">0</span> â€¢ Lives: <span id="lives">3</span></div>
    <div><button id="start">Start</button><button id="restart">Restart</button></div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('start');
  const restartBtn = document.getElementById('restart');
  const scoreEl = document.getElementById('score'), livesEl = document.getElementById('lives');

  let W = canvas.width, H = canvas.height;
  let paddle, ball, bricks, rows=5, cols=9, brickW, brickH=18, running=false, score=0, lives=3, animId;

  function init(){
    W = canvas.width; H = canvas.height;
    paddle = {w:120,h:16,x:(W-120)/2,y:H-50, speed:12};
    ball = {x:W/2,y:H-80,r:9,vx:4,vy:-4};
    bricks = [];
    brickW = Math.floor((W - (cols+1)*8) / cols);
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = 8 + c*(brickW+8);
        const y = 40 + r*(brickH+8);
        bricks.push({x,y,w:brickW,h:brickH,alive:true, hits:1});
      }
    }
    score = 0; lives = 3; scoreEl.textContent = score; livesEl.textContent = lives;
    running = false;
    draw();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    // bg
    ctx.fillStyle = '#041028'; ctx.fillRect(0,0,W,H);
    // bricks
    bricks.forEach(b=>{
      if(!b.alive) return;
      ctx.fillStyle = '#ffd54f';
      roundRect(ctx, b.x, b.y, b.w, b.h, 6, true);
    });
    // paddle
    ctx.fillStyle = '#ff9800'; roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8, true);
    // ball
    ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();
  }

  function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); }

  function update(){
    if(!running) return;
    // move ball
    ball.x += ball.vx; ball.y += ball.vy;
    // wall collisions
    if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
    if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }
    if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }
    // paddle collision
    if(ball.y + ball.r > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.w && ball.vy > 0){
      const hitPos = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      ball.vx = 6 * hitPos;
      ball.vy *= -1;
      ball.y = paddle.y - ball.r - 1;
    }
    // bottom miss
    if(ball.y - ball.r > H){
      lives--; livesEl.textContent = lives;
      if(lives <= 0){ gameOver(); return; } else {
        resetBall();
      }
    }
    // bricks collision
    for(let i=0;i<bricks.length;i++){
      const b = bricks[i];
      if(!b.alive) continue;
      if(ball.x + ball.r > b.x && ball.x - ball.r < b.x + b.w && ball.y + ball.r > b.y && ball.y - ball.r < b.y + b.h){
        // simple reflect
        // determine side
        const prevX = ball.x - ball.vx, prevY = ball.y - ball.vy;
        if(prevX + ball.r <= b.x || prevX - ball.r >= b.x + b.w) ball.vx *= -1; else ball.vy *= -1;
        b.alive = false;
        score += 10; scoreEl.textContent = score;
        break;
      }
    }

    // win check
    if(bricks.every(b => !b.alive)){ win(); return; }
    draw();
    animId = requestAnimationFrame(update);
  }

  function resetBall(){
    ball.x = W/2; ball.y = H/2; ball.vx = (Math.random() > 0.5 ? 4 : -4); ball.vy = -4;
    running = false;
    draw();
  }

  function start(){
    if(running) return;
    running = true;
    animId = requestAnimationFrame(update);
  }

  function gameOver(){
    running = false;
    cancelAnimationFrame(animId);
    alert('Game Over. Score: ' + score);
    init();
  }

  function win(){
    running = false;
    cancelAnimationFrame(animId);
    alert('You cleared all bricks! Score: ' + score);
    init();
  }

  // controls: mouse/touch move paddle
  let dragging = false;
  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    paddle.x = Math.max(0, Math.min(W - paddle.w, mx - paddle.w/2));
    draw();
  });
  canvas.addEventListener('touchmove', e => {
    const rect = canvas.getBoundingClientRect();
    const t = e.touches[0];
    const mx = t.clientX - rect.left;
    paddle.x = Math.max(0, Math.min(W - paddle.w, mx - paddle.w/2));
    draw();
  }, {passive:true});

  // keyboard control
  document.addEventListener('keydown', e => {
    if(e.key === 'ArrowLeft') paddle.x = Math.max(0, paddle.x - 30);
    if(e.key === 'ArrowRight') paddle.x = Math.min(W - paddle.w, paddle.x + 30);
    if(e.key === ' ') start();
    draw();
  });

  startBtn.addEventListener('click', start);
  restartBtn.addEventListener('click', init);

  // responsive
  function resize(){
    const maxW = Math.min(window.innerWidth * 0.95, 900);
    canvas.width = Math.floor(maxW);
    canvas.height = Math.floor(Math.min(window.innerHeight * 0.7, 520));
    W = canvas.width; H = canvas.height;
    init();
  }
  window.addEventListener('resize', resize);

  // initial
  resize();
})();
</script>
</body>
</html>
